import { __decorate } from "tslib";
import { join, normalize, relative } from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import { bind } from '@roots/bud-support/decorators/bind';
import { BudError } from '@roots/bud-support/errors';
import { resolve } from '@roots/bud-support/import-meta-resolve';
import isEqual from '@roots/bud-support/isEqual';
import logger from '@roots/bud-support/logger';
import noop from '@roots/bud-support/noop';
import {} from './index.js';
import { Service } from './service.js';
/**
 * Module resolver
 */
export class Module extends Service {
    /**
     * Cached resolutions data
     */
    cache = {
        resolutions: {},
        sha1: null,
        version: null,
    };
    /**
     * Resolved module paths
     */
    resolutions = {};
    /**
     * Cache enabled
     */
    get cacheEnabled() {
        return this.args.force !== true;
    }
    /**
     * Cache location
     */
    get cachePath() {
        return join(this.paths.storage, `bud.resolutions.yml`);
    }
    /**
     * Constructor
     */
    constructor(options) {
        super(options.app);
        this.args = options.args;
        this.paths = options.paths;
    }
    /**
     * {@link Service.bootstrap}
     */
    async bootstrap(bud) {
        if (!this.cacheEnabled) {
            logger.scope(`module`).log(`--force used. resetting cache.`);
            return await this.removeCachedResolutions();
        }
        if (await bud.fs.exists(this.cachePath)) {
            logger.scope(`module`).log(`cache is enabled and exists`);
            const cache = await bud.fs.read(this.cachePath).catch(noop);
            if (cache)
                this.cache = cache;
            this.resolutions = { ...this.cache.resolutions };
        }
        if (!this.cache?.resolutions ||
            this.cache?.sha1 !== bud.context.files[`package`]?.sha1) {
            logger
                .scope(`module`)
                .log(`cache is enabled but package.json has changed. resetiing cache.`);
            return await this.removeCachedResolutions();
        }
    }
    /**
     * At end of process write resolutions to cache
     */
    async after(bud) {
        if (isEqual(this.cache.resolutions, this.resolutions)) {
            logger
                .scope(`module`)
                .log(`resolutions unchanged. skipping write.`)
                .info(`resolutions:`, this.resolutions)
                .info(`cache:`, this.cache);
            return bud;
        }
        await this.writeResolutions();
        return bud;
    }
    /**
     * Handle error
     *
     * @param messages - error messages for logging
     * @returns
     */
    async handleError(...messages) {
        messages.length && logger.scope(`module`).log(...messages);
        await this.removeCachedResolutions(messages.join(` `));
        throw BudError.normalize(messages.join(` `));
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getDirectory(signifier, context) {
        logger.scope(`module`).info(`getDirectory`, signifier, context);
        return await this.resolve(signifier, context)
            .then(path => relative(this.app.context.basedir, path))
            .then(path => path.split(signifier).shift())
            .then(path => this.app.path(path, signifier))
            .catch(this.catch);
    }
    /**
     * Get `package.json` absolute path from a module signifier
     */
    async getManifestPath(signifier) {
        logger.scope(`module`).info(`getManifestPath`, signifier);
        return await this.getDirectory(signifier)
            .then(dir => this.app.path(dir, `package.json`))
            .catch(this.catch);
    }
    /**
     * Import a module from its signifier
     */
    async import(signifier, context, options = {
        bustCache: false,
        raw: false,
    }) {
        if (options.bustCache) {
            signifier = `${signifier}?v=${Date.now()}`;
        }
        if (!this.hasResolution(signifier)) {
            await this.resolve(signifier, context).catch(this.catch);
        }
        const code = await import(this.getResolution(signifier)).catch(async (error) => {
            return await this.handleError(error.message ?? error);
        });
        if (!code) {
            return await this.handleError(`Could not import ${signifier}`);
        }
        logger.scope(`module`).log(`imported module:`, signifier);
        return options.raw ? code : code?.default ?? code;
    }
    /**
     * Make context URL
     */
    makeContextURL(context) {
        if (context instanceof URL)
            return context;
        if (context)
            return pathToFileURL(context);
        return pathToFileURL(join(this.app.context.basedir, `package.json`));
    }
    /**
     * Read `package.json` manifest from a module signifier
     */
    async readManifest(signifier) {
        return await this.getManifestPath(signifier).then(async (path) => {
            const value = await this.app.fs.read(path);
            logger.scope(`module`).info(signifier, `manifest`, value);
            return value;
        });
    }
    /**
     * Reset cached resolutions
     */
    async removeCachedResolutions(error) {
        if (await this.app.fs.exists(this.cachePath)) {
            logger.scope(`module`).log(`removing cache file`, this.cachePath);
            await this.app.fs.remove(this.cachePath);
        }
        if (error) {
            await this.writeResolutions(this.cachePath.replace(`bud.resolutions.yml`, `bud.error.resolutions.yml`), { date: Date.now(), error });
        }
        this.cache = {
            resolutions: {},
            sha1: this.app.context.files[`package`]?.sha1,
            version: this.app.context.bud?.version,
        };
        this.resolutions = {};
    }
    /**
     * Resolve a module path from its signifier
     */
    async resolve(signifier, context) {
        if (this.hasResolution(signifier)) {
            return this.getResolution(signifier);
        }
        await resolve(signifier, this.makeContextURL())
            .then(path => {
            this.setResolution(signifier, normalize(fileURLToPath(path)));
            logger
                .scope(`module`)
                .log(`[cache miss]`, `path:`, signifier, `=>`, this.getResolution(signifier));
        })
            .catch(noop);
        if (this.hasResolution(signifier))
            return this.getResolution(signifier);
        await resolve(signifier, this.makeContextURL(context))
            .then(path => {
            this.setResolution(signifier, normalize(fileURLToPath(path)));
            logger
                .scope(`module`)
                .log(`[cache miss]`, `path:`, signifier, `=>`, this.getResolution(signifier));
        })
            .catch(noop);
        if (this.hasResolution(signifier)) {
            return this.getResolution(signifier);
        }
        await this.handleError(`Could not resolve`, signifier);
    }
    /**
     * Write resolutions to cache
     */
    async writeResolutions(path, data) {
        logger
            .scope(`module`)
            .log(`writing resolutions`)
            .info(this.resolutions);
        await this.app.fs.write(path ?? this.cachePath, {
            resolutions: this.resolutions,
            sha1: this.app.context.files[`package`]?.sha1,
            version: this.app.context.bud.version,
            ...(data ?? {}),
        });
    }
    /**
     * Get a module resolution path
     */
    getResolution(signifier) {
        logger
            .scope(`module`)
            .info(`resolved:`, signifier, `=>`, this.resolutions[signifier]);
        return this.resolutions[signifier];
    }
    /**
     * Check if a module has been resolved
     */
    hasResolution(signifier) {
        return signifier in this.resolutions;
    }
    /**
     * Remove a module resolution path
     *
     * @param signifier
     * @returns
     */
    removeResolution(signifier) {
        return delete this.resolutions[signifier];
    }
    /**
     * Set a module resolution path
     */
    setResolution(signifier, url) {
        this.resolutions[signifier] = url;
    }
}
__decorate([
    bind
], Module.prototype, "bootstrap", null);
__decorate([
    bind
], Module.prototype, "after", null);
__decorate([
    bind
], Module.prototype, "getDirectory", null);
__decorate([
    bind
], Module.prototype, "getManifestPath", null);
__decorate([
    bind
], Module.prototype, "import", null);
__decorate([
    bind
], Module.prototype, "makeContextURL", null);
__decorate([
    bind
], Module.prototype, "readManifest", null);
__decorate([
    bind
], Module.prototype, "removeCachedResolutions", null);
__decorate([
    bind
], Module.prototype, "resolve", null);
__decorate([
    bind
], Module.prototype, "getResolution", null);
__decorate([
    bind
], Module.prototype, "hasResolution", null);
__decorate([
    bind
], Module.prototype, "removeResolution", null);
__decorate([
    bind
], Module.prototype, "setResolution", null);
